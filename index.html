<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>WebChat Deluxe V1.4.2</title>
<link rel="stylesheet" href="styles.css">
<link rel="stylesheet" href="extra.css">
</head>
<body>

<div class="container">
  <div class="sidebar">
    <h2>WebChat Deluxe V1.4.2</h2>
    <div id="authArea">
      <input type="email" id="email" placeholder="E-Mail"><br><br>
      <input type="password" id="password" placeholder="Passwort"><br><br>
      <button type="button" onclick="signup()">Registrieren</button>
      <button type="button" style="margin-top:8px;background:#059669" onclick="login()">Anmelden</button>
    </div>
<button id="showUpdateBtn">Updates anzeigen</button>
<div id="updatePopup">
  <h4>Neues in V1.4.2</h4>
  <ul>
    <li>Call-Signalisierung via Firestore</li>
    <li>Discord-Style Call-Popup</li>
    <li>Klingelton + Notification</li>
    <li>ICE Kandidaten-Austausch</li>
    <li>Bugfixes & UI Tweaks</li>
  </ul>
</div>

    <div id="userArea" style="display:none;">
      <div id="userInfo"></div>
      <button type="button" style="background:#dc2626;margin-top:8px" onclick="logout()">Abmelden</button>
      <hr/>
      <h4>Kontakte</h4>
      <div id="contacts"></div>
      <input id="addContactInput" placeholder="Name hinzuf√ºgen"><br>
      <button type="button" style="margin-top:6px" onclick="addContactByName()">Hinzuf√ºgen</button>
      <hr/>
      <h4>Gruppen</h4>
      <div id="groups"></div>
      <input id="newGroupName" placeholder="Gruppenname"><br>
      <button type="button" style="margin-top:6px" onclick="createGroup()">Erstellen</button>
    </div>
  </div>

  <div class="main">
    <div id="chatHeader" class="chat-header">
      <h3 id="chatTitle">Bitte anmelden</h3>
      <div class="call-buttons" id="callButtons" style="display:none;">
        <button id="audioCallBtn" title="Sprachanruf starten">üìû</button>
        <button id="videoCallBtn" title="Videoanruf starten">üé•</button>
        <button id="endCallBtn" title="Auflegen" style="display:none;">‚ùå</button>
      </div>
    </div>

    <div id="chatBox" class="chat-box"></div>

    <div style="display:flex;flex-direction:column;gap:4px;margin-top:8px;">
      <div style="display:flex;gap:8px;">
        <input id="messageInput" placeholder="Nachricht..." style="flex:1">
        <input type="file" id="imageInput" accept="image/*">
        <button type="button" onclick="sendMessage()">Senden</button>
        <button type="button" id="sendImageBtn">Bild senden</button>
      </div>
      <img id="previewImg" style="display:none;max-width:200px;border-radius:8px;">
    </div>

    <div id="videoContainer" style="display:none;flex-direction:column;align-items:center;margin-top:10px;">
      <video id="localVideo" autoplay muted playsinline style="width:40%;border-radius:10px;"></video>
      <video id="remoteVideo" autoplay playsinline style="width:40%;border-radius:10px;margin-top:10px;"></video>
    </div>

    <audio id="remoteAudio" autoplay playsinline></audio>
  </div>
</div>

<!-- Incoming call popup (Discord-style) -->
<div id="incomingPopup" class="incoming-popup" style="display:none;">
  <div class="incoming-popup-backdrop"></div>
  <div class="incoming-popup-card">
    <div class="incoming-popup-header">
      <div class="caller-avatar">üìû</div>
      <div>
        <h3 id="popupTitle">Eingehender Anruf</h3>
        <p id="popupCaller" class="popup-caller">...</p>
      </div>
    </div>
    <div class="incoming-popup-actions">
      <button id="acceptCallBtn" class="btn accept">Annehmen</button>
      <button id="declineCallBtn" class="btn decline">Ablehnen</button>
    </div>
  </div>
</div>

<script type="module">
/* -------------------------
   Firebase & Imports
------------------------- */
import { initializeApp } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-app.js";
import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-analytics.js";
import {
  getAuth,
  onAuthStateChanged,
  createUserWithEmailAndPassword,
  signInWithEmailAndPassword,
  signOut
} from "https://www.gstatic.com/firebasejs/12.4.0/firebase-auth.js";
import {
  getFirestore,
  doc,
  setDoc,
  collection,
  addDoc,
  query,
  where,
  getDocs,
  onSnapshot,
  orderBy,
  updateDoc,
  getDoc
} from "https://www.gstatic.com/firebasejs/12.4.0/firebase-firestore.js";
import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-storage.js";

/* --- FIREBASE CONFIG --- */
const firebaseConfig = {
  apiKey: "AIzaSyCFgiS9au7GOzhJ7_ayBcBM3bZrEm5GJOA",
  authDomain: "webchat-a47cc.firebaseapp.com",
  databaseURL: "https://webchat-a47cc-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "webchat-a47cc",
  storageBucket: "webchat-a47cc.appspot.com",
  messagingSenderId: "318380716143",
  appId: "1:318380716143:web:da7474bfa392dfeaccdd9a",
  measurementId: "G-GBFBS5F8GB"
};

const app = initializeApp(firebaseConfig);
const analytics = getAnalytics(app);
const auth = getAuth(app);
const db = getFirestore(app);
const storage = getStorage(app);

/* -------------------------
   UI Elemente
------------------------- */
const authArea = document.getElementById('authArea');
const userArea = document.getElementById('userArea');
const userInfo = document.getElementById('userInfo');
const contactsDiv = document.getElementById('contacts');
const groupsDiv = document.getElementById('groups');
const chatBox = document.getElementById('chatBox');
const chatTitle = document.getElementById('chatTitle');
const callButtons = document.getElementById('callButtons');
const audioCallBtn = document.getElementById('audioCallBtn');
const videoCallBtn = document.getElementById('videoCallBtn');
const endCallBtn = document.getElementById('endCallBtn');
const videoContainer = document.getElementById('videoContainer');
const localVideo = document.getElementById('localVideo');
const remoteVideo = document.getElementById('remoteVideo');
const remoteAudio = document.getElementById('remoteAudio');
const messageInput = document.getElementById('messageInput');
const imageInput = document.getElementById('imageInput');
const sendImageBtn = document.getElementById('sendImageBtn');
const previewImg = document.getElementById('previewImg');

const incomingPopup = document.getElementById('incomingPopup');
const popupCallerTxt = document.getElementById('popupCaller');
const acceptCallBtn = document.getElementById('acceptCallBtn');
const declineCallBtn = document.getElementById('declineCallBtn');

/* --- Sounds --- */
const outgoingCallSound = new Audio('https://www.soundjay.com/phone/phone-dial-01.mp3');
outgoingCallSound.loop = true;
const incomingCallSound = new Audio('https://www.soundjay.com/phone/phone-ring-01.mp3');
incomingCallSound.loop = true;
const messageSound = new Audio('https://www.soundjay.com/button/beep-07.mp3');

/* --- Notifications --- */
let notifyAllowed = false;
async function requestNotificationPermission(){
  if(!("Notification" in window)) return false;
  if(Notification.permission === "granted") return true;
  const permission = await Notification.requestPermission();
  return permission === "granted";
}
requestNotificationPermission().then(granted => notifyAllowed = granted);
function showNotification(title, body){
  if(!notifyAllowed) return;
  try { new Notification(title, { body }); messageSound.play().catch(()=>{}); } 
  catch(e){}
}

/* -------------------------
   State
------------------------- */
let me = null;
let selectedPeer = null;
let unreadCounts = {};
let pc = null;
let localStream = null;
let callDocRef = null;
let selectedFile = null;

/* ICE servers */
const ICE_SERVERS = [{urls:'stun:stun.l.google.com:19302'}];

/* -------------------------
   Auth Funktionen
------------------------- */
window.signup = async () => {
  const email = document.getElementById('email').value;
  const pw = document.getElementById('password').value;
  if(!email || !pw){ alert("E-Mail + Passwort angeben"); return; }
  try { await createUserWithEmailAndPassword(auth, email, pw); } 
  catch(e){ alert(e.message || e); }
};

window.login = async () => {
  const email = document.getElementById('email').value;
  const pw = document.getElementById('password').value;
  if(!email || !pw){ alert("E-Mail + Passwort angeben"); return; }
  try { await signInWithEmailAndPassword(auth, email, pw); } 
  catch(e){ alert(e.message || e); }
};

window.logout = async () => {
  try { await signOut(auth); } catch(e){ console.error(e); }
  selectedPeer = null;
  chatBox.innerHTML = '';
};

/* -------------------------
   Auth State Listener
------------------------- */
onAuthStateChanged(auth, async user => {
  if(user){
    me = { uid: user.uid, email: user.email, name: (user.email || '').split('@')[0] || 'User' };
    try { await setDoc(doc(db,'users',me.uid), me, { merge: true }); } 
    catch(e) { console.error(e); }
    authArea.style.display = 'none';
    userArea.style.display = 'block';
    userInfo.textContent = `Angemeldet als ${me.name}`;
    loadContacts();
    loadGroups();
    chatTitle.textContent = 'W√§hle einen Chat';
  } else {
    me = null;
    authArea.style.display = 'block';
    userArea.style.display = 'none';
    chatTitle.textContent = 'Bitte anmelden';
    chatBox.innerHTML = '';
  }
});

/* -------------------------
   Kontakte & Gruppen
------------------------- */
async function loadContacts(){
  contactsDiv.innerHTML = '';
  const q = query(collection(db,'users'));
  const snap = await getDocs(q);
  snap.forEach(docu => {
    const u = docu.data();
    if(u.uid !== me.uid){
      const div = document.createElement('div');
      div.className = 'contact-item';
      const nameSpan = document.createElement('span');
      nameSpan.textContent = u.name || u.email || 'User';
      const countSpan = document.createElement('span');
      countSpan.id = 'unread-' + u.uid;
      countSpan.textContent = unreadCounts[u.uid] || '';
      div.appendChild(nameSpan);
      div.appendChild(countSpan);
      div.onclick = () => {
        selectedPeer = { type: 'user', id: u.uid, name: u.name || u.email };
        unreadCounts[u.uid] = 0;
        updateUnreadBadge(u.uid);
        loadChat();
      };
      contactsDiv.appendChild(div);
    }
  });
}

async function loadGroups(){
  groupsDiv.innerHTML = '';
  const q = query(collection(db,'groups'), where('members','array-contains', me.uid));
  const snap = await getDocs(q);
  snap.forEach(docu => {
    const g = docu.data();
    const div = document.createElement('div');
    div.className = 'group-item';
    const nameSpan = document.createElement('span');
    nameSpan.textContent = g.name || 'Gruppe';
    const countSpan = document.createElement('span');
    countSpan.id = 'unread-' + docu.id;
    countSpan.textContent = unreadCounts[docu.id] || '';
    div.appendChild(nameSpan);
    div.appendChild(countSpan);
    div.onclick = () => {
      selectedPeer = { type: 'group', id: docu.id, name: g.name };
      unreadCounts[docu.id] = 0;
      updateUnreadBadge(docu.id);
      loadChat();
    };
    groupsDiv.appendChild(div);
  });
}

/* -------------------------
   Chat & Nachrichten
------------------------- */
async function loadChat(){
  if(!selectedPeer){ chatTitle.textContent = 'W√§hle einen Chat'; callButtons.style.display = 'none'; return; }
  chatTitle.textContent = selectedPeer.name || 'Chat';
  callButtons.style.display = selectedPeer.type === 'user' ? 'flex' : 'none';
  chatBox.innerHTML = '';

  let messagesQuery;
  if(selectedPeer.type === 'user'){
    messagesQuery = query(collection(db,'messages'), orderBy('timestamp'));
  } else {
    messagesQuery = query(collection(db,'messages'), where('to','==', selectedPeer.id), orderBy('timestamp'));
  }

  onSnapshot(messagesQuery, snap => {
    chatBox.innerHTML = '';
    snap.forEach(docu => {
      const m = docu.data();
      if(selectedPeer.type === 'user'){
        if((m.from === me.uid && m.to === selectedPeer.id) || (m.from === selectedPeer.id && m.to === me.uid)){
          renderMessage(m);
          if(m.from !== me.uid) showNotification(selectedPeer.name, m.type==='text'?m.text:'Bildnachricht');
        } else if(m.from!==me.uid && m.to===me.uid){
          unreadCounts[m.from]=(unreadCounts[m.from]||0)+1;
          updateUnreadBadge(m.from);
        }
      } else {
        if(m.to===selectedPeer.id){
          renderMessage(m);
          if(m.from!==me.uid) showNotification(selectedPeer.name, m.type==='text'?m.text:'Bildnachricht');
        }
      }
    });
    chatBox.scrollTop = chatBox.scrollHeight;
  });
}

function renderMessage(m){
  if(m.type==='image'){
    const img = document.createElement('img');
    img.src = m.url;
    img.className = 'chat-img message ' + (m.from===me.uid?'sent':'received');
    chatBox.appendChild(img);
  } else {
    const div = document.createElement('div');
    div.textContent = m.text;
    div.className = 'message ' + (m.from===me.uid?'sent':'received');
    chatBox.appendChild(div);
  }
}

window.sendMessage = async () => {
  if(!selectedPeer){ alert('Chat ausw√§hlen'); return; }
  const text = messageInput.value.trim();
  if(!text) return;
  await addDoc(collection(db,'messages'), { from: me.uid, to: selectedPeer.id, type:'text', text, timestamp:Date.now() });
  messageInput.value='';
}

/* -------------------------
   Image Upload & Send
------------------------- */
imageInput.addEventListener('change', (e) => {
  selectedFile = e.target.files[0];
  if(selectedFile){ previewImg.src = URL.createObjectURL(selectedFile); previewImg.style.display='block'; } 
  else previewImg.style.display='none';
});

async function sendImage(){
  if(!selectedPeer){ alert('Chat ausw√§hlen'); return; }
  if(!selectedFile){ alert('Keine Datei gew√§hlt'); return; }
  const cleanName = selectedFile.name.replace(/[^\w.-]/g,"_");
  const path = `chatImages/${me.uid}_${Date.now()}_${cleanName}`;
  const storageRef = ref(storage,path);
  const snapshot = await uploadBytes(storageRef,selectedFile);
  const url = await getDownloadURL(snapshot.ref);
  await addDoc(collection(db,'messages'), { from:me.uid,to:selectedPeer.id,type:'image',url,timestamp:Date.now() });
  selectedFile=null; imageInput.value=''; previewImg.style.display='none';
}

sendImageBtn.addEventListener('click', sendImage);

/* -------------------------
   Unread Badge
------------------------- */
function updateUnreadBadge(chatId){
  const span = document.getElementById('unread-'+chatId);
  if(span) span.textContent = unreadCounts[chatId]||'';
}

/* -------------------------
   WebRTC Audio/Video Calls (Signaling √ºber Firestore)
------------------------- */
const callsCol = collection(db, "calls");

/* Start local peer connection, add tracks and handlers */
function setupPeerConnection() {
  pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });

  pc.onicecandidate = (event) => {
    if (!event.candidate || !callDocRef) return;
    const cand = event.candidate.toJSON();
    const candidatesCol = (pc.__role === 'caller') ? collection(callDocRef, 'offerCandidates') : collection(callDocRef, 'answerCandidates');
    // add candidate to appropriate subcollection
    addDoc(candidatesCol, cand).catch(e => console.error("candidate push failed", e));
  };

  pc.ontrack = (e) => {
    try {
      remoteVideo.srcObject = e.streams[0];
      remoteAudio.srcObject = e.streams[0];
    } catch (e) { console.error(e); }
  };

  return pc;
}

/* Create call document (caller side) */
async function createCallDocument(video = false) {
  callDocRef = doc(callsCol);
  // create peer connection and set role so ice handler writes to offerCandidates
  setupPeerConnection();
  pc.__role = 'caller';

  // add local tracks
  if (localStream) localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);

  const callData = {
    from: me.uid,
    to: selectedPeer.id,
    type: video ? "video" : "audio",
    offer: offer.toJSON ? offer.toJSON() : offer,
    active: true,
    created: Date.now()
  };
  await setDoc(callDocRef, callData);

  // listen for answer
  onSnapshot(callDocRef, (snap) => {
    const data = snap.data();
    if (!data) return;
    if (data.answer && pc && !pc.__remoteSet) {
      pc.__remoteSet = true;
      const answerDesc = new RTCSessionDescription(data.answer);
      pc.setRemoteDescription(answerDesc).catch(e => console.error("setRemoteDescription failed", e));
    }
    if (data.active === false) {
      // caller sees that call was declined/ended
      endCall(true);
    }
  });

  // listen for remote ICE (answerCandidates)
  const answerCandidatesCol = collection(callDocRef, 'answerCandidates');
  onSnapshot(answerCandidatesCol, (snap) => {
    snap.docChanges().forEach(change => {
      if(change.type === 'added'){
        const c = change.doc.data();
        pc.addIceCandidate(new RTCIceCandidate(c)).catch(e => console.error(e));
      }
    });
  });

  return callDocRef;
}

/* Start a call (caller) */
async function startCall(video=false){
  if(!selectedPeer){ alert("Chat ausw√§hlen"); return; }
  try{
    localStream = await navigator.mediaDevices.getUserMedia({ audio:true, video:video });
    localVideo.srcObject = localStream;
    videoContainer.style.display = video?"flex":"none";
  } catch(e){ alert("Kamera/Mikrofon nicht verf√ºgbar"); return; }

  await createCallDocument(video);
  outgoingCallSound.play();

  audioCallBtn.style.display='none'; videoCallBtn.style.display='none'; endCallBtn.style.display='inline-block';
}

/* End call and cleanup */
async function endCall(silent=false){
  try{
    if(callDocRef){
      await updateDoc(callDocRef, { active: false }).catch(()=>{});
    }
  } catch(e){ console.warn(e); }

  if(pc){ pc.close(); pc = null; }
  if(localStream) localStream.getTracks().forEach(t=>t.stop());
  localStream = null;
  callDocRef = null;
  outgoingCallSound.pause();
  incomingCallSound.pause();
  videoContainer.style.display='none';
  audioCallBtn.style.display='inline-block';
  videoCallBtn.style.display='inline-block';
  endCallBtn.style.display='none';
}

/* Accept (answer) flow */
async function answerCall(callDocSnap){
  const callId = callDocSnap.id;
  const callData = callDocSnap.data();
  if(!callData) return;

  callDocRef = doc(callsCol, callId);
  // create peer connection and set role so ice handler writes to answerCandidates
  setupPeerConnection();
  pc.__role = 'answerer';

  try {
    localStream = await navigator.mediaDevices.getUserMedia({ audio:true, video: callData.type === 'video' });
    localVideo.srcObject = localStream;
    videoContainer.style.display = callData.type === 'video' ? 'flex' : 'none';
  } catch(e){ alert("Kamera/Mikrofon nicht verf√ºgbar"); return; }

  // add local tracks
  if (localStream) localStream.getTracks().forEach(t => pc.addTrack(t, localStream));

  // set remote (offer)
  const offerDesc = new RTCSessionDescription(callData.offer);
  await pc.setRemoteDescription(offerDesc);

  // create answer
  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);

  // write answer to firestone doc
  await updateDoc(callDocRef, { answer: answer.toJSON ? answer.toJSON() : answer, active: true });

  // listen for offerCandidates (caller -> answerer)
  const offerCandidatesCol = collection(callDocRef, 'offerCandidates');
  onSnapshot(offerCandidatesCol, snap => {
    snap.docChanges().forEach(change => {
      if(change.type === 'added'){
        const c = change.doc.data();
        pc.addIceCandidate(new RTCIceCandidate(c)).catch(e => console.error(e));
      }
    });
  });

  // listen for call active flag changes (caller hangs up)
  onSnapshot(callDocRef, (snap) => {
    const data = snap.data();
    if(!data) return;
    if (data.active === false) {
      endCall(true);
    }
  });

  audioCallBtn.style.display='none'; videoCallBtn.style.display='none'; endCallBtn.style.display='inline-block';
}

/* -------------------------
   Incoming calls watcher (listens for calls where to == me.uid)
------------------------- */
onSnapshot(query(callsCol, where("to", "==", () => me ? me.uid : "___not_set___")), (snap) => {
  // Note: Firestore SDK won't accept a function predicate; we'll instead attach watcher once me is defined
});

/* set up real incoming watcher after auth (so me.uid exists) */
function setupIncomingWatcher(){
  if(!me) return;
  const q = query(callsCol, where("to", "==", me.uid));
  onSnapshot(q, async (snap) => {
    snap.docChanges().forEach(async change => {
      if(change.type === 'added'){
        const data = change.doc.data();
        if(!data || !data.active) return;
        // get caller info
        let callerName = 'Unbekannt';
        try{
          const callerSnap = await getDoc(doc(db, 'users', data.from));
          if(callerSnap.exists()) callerName = callerSnap.data().name || callerName;
        }catch(e){}

        // show popup
        popupCallerTxt.textContent = `${callerName} ruft dich an (${data.type === 'video' ? 'Video' : 'Audio'})`;
        incomingPopup.classList.add('show');
        incomingPopup.style.display = 'block';
        incomingCallSound.play().catch(()=>{});
        showNotification('Eingehender Anruf', `${callerName} ruft dich an`);

        // attach handlers (fresh for this call)
        acceptCallBtn.onclick = async () => {
          incomingPopup.classList.remove('show');
          incomingPopup.style.display = 'none';
          incomingCallSound.pause();
          await answerCall(change.doc);
        };
        declineCallBtn.onclick = async () => {
          incomingPopup.classList.remove('show');
          incomingPopup.style.display = 'none';
          incomingCallSound.pause();
          await updateDoc(change.doc.ref, { active: false }).catch(()=>{});
        };
      }
    });
  });
}

/* run watcher after auth ready */
onAuthStateChanged(auth, (u) => {
  if(u) setTimeout(setupIncomingWatcher, 500);
});

/* -------------------------
   Buttons hookup
------------------------- */
audioCallBtn.onclick = () => startCall(false);
videoCallBtn.onclick = () => startCall(true);
endCallBtn.onclick = () => endCall();

/* -------------------------
   Update Popup (floating button)
------------------------- */
const updateBtn = document.createElement('button');
updateBtn.textContent = 'Changelog anzeigen';
updateBtn.className = 'floating-update-btn';
document.body.appendChild(updateBtn);

const updateDiv = document.createElement('div');
updateDiv.innerHTML = `<h3>V1.4.2 Update</h3>
<ul>
<li>Call-Signalisierung (Firestore)</li>
<li>Discord-style Popup</li>
<li>Klingelton & Notifications</li>
</ul>`;
updateDiv.className = 'floating-update-panel';
document.body.appendChild(updateDiv);

let updateVisible = false;
updateBtn.onclick = ()=>{
  updateVisible = !updateVisible;
  updateDiv.style.display = updateVisible?'block':'none';
}

/* -------------------------
   Helper: small utilities (stubs for addContactByName/createGroup used elsewhere)
------------------------- */
window.addContactByName = async () => {
  const n = document.getElementById('addContactInput').value.trim();
  if(!n) return alert('Name angeben');
  // minimal demo: create a fake user doc (in real use, you'd invite someone properly)
  const fakeId = 'tmp_' + Date.now();
  await setDoc(doc(db,'users',fakeId), { uid: fakeId, name: n, email: `${n}@example.local` });
  loadContacts();
};
window.createGroup = async () => {
  const name = document.getElementById('newGroupName').value.trim();
  if(!name) return alert('Gruppenname angeben');
  await addDoc(collection(db,'groups'), { name, members: [me.uid], created: Date.now() });
  loadGroups();
};

</script>

</body>
</html>











