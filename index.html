<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>WebChat Deluxe V1.4.3 (GitHub-ready)</title>
<style>
  :root{--accent:#059669;--muted:#6b7280}
  body{margin:0;font-family:Inter,Arial,sans-serif;background:#0f172a;color:#111827;height:100vh;display:flex}
  .container{display:flex;flex:1;gap:10px;padding:12px}
  .sidebar{width:280px;background:#0b1220;border-radius:8px;padding:12px;color:#fff;display:flex;flex-direction:column;gap:8px;box-shadow:0 6px 18px rgba(2,6,23,.6)}
  .main{flex:1;background:#fff;border-radius:8px;padding:12px;display:flex;flex-direction:column;min-width:0}
  h2,h3,h4{margin:0 0 6px 0}
  input,button,select{font:inherit}
  input[type="text"],input[type="email"],input[type="password"]{width:100%;padding:8px;border-radius:6px;border:1px solid #cbd5e1}
  button{padding:8px 10px;border-radius:8px;border:0;background:var(--accent);color:#fff;cursor:pointer}
  .muted{color:var(--muted)}
  .contacts, .groups{display:flex;flex-direction:column;gap:6px;max-height:200px;overflow:auto;padding-right:6px}
  .contact-item, .group-item{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:6px;background:rgba(255,255,255,0.03);cursor:pointer}
  .chat-header{display:flex;justify-content:space-between;align-items:center;padding-bottom:8px;border-bottom:1px solid #e6edf3}
  .chat-box{flex:1;margin-top:10px;overflow:auto;padding:10px;border-radius:8px;background:#f3f4f6;display:flex;flex-direction:column;gap:8px}
  .message{max-width:72%;padding:8px 10px;border-radius:10px;word-break:break-word}
  .sent{background:#dcfce7;align-self:flex-end}
  .received{background:#f8fafc;align-self:flex-start}
  .typing-indicator{padding:6px 10px;font-size:13px;color:#374151;background:rgba(0,0,0,0.03);border-radius:6px;margin-top:6px}
  .input-row{display:flex;gap:8px;margin-top:8px;align-items:center}
  .input-row input[type="text"]{flex:1}
  .video-grid{display:flex;flex-wrap:wrap;gap:8px;margin-top:12px}
  .video-grid video{width:320px;height:180px;border-radius:8px;background:#000;object-fit:cover}
  .small-btn{padding:6px 8px;border-radius:6px;background:#111827;color:#fff}
  .badge{background:#ef4444;color:#fff;padding:2px 6px;border-radius:999px;font-size:12px}
  .preview-img{max-width:160px;border-radius:8px;margin-top:6px}
  .incoming-popup{position:fixed;left:50%;top:18%;transform:translateX(-50%);background:#fff;padding:16px;border-radius:8px;box-shadow:0 8px 30px rgba(2,6,23,.5);z-index:999}
  .footer-small{font-size:12px;color:#6b7280;margin-top:8px}
  @media(max-width:900px){ .sidebar{display:none} .video-grid video{width:48vw;height:28vw} }
</style>
</head>
<body>
<div class="container">
  <div class="sidebar" id="sidebar">
    <h2>WebChat Deluxe <small style="font-weight:600">V1.4.3</small></h2>

    <div id="authArea">
      <input id="email" type="email" placeholder="E-Mail">
      <input id="password" type="password" placeholder="Passwort">
      <div style="display:flex;gap:8px">
        <button onclick="signup()">Registrieren</button>
        <button onclick="login()" style="background:#1d4ed8">Anmelden</button>
      </div>
    </div>

    <div id="userArea" style="display:none">
      <div id="userInfo" class="muted">‚Äî</div>
      <div style="display:flex;gap:8px;margin-top:6px">
        <button onclick="logout()" style="background:#ef4444">Abmelden</button>
        <button id="myProfileBtn" class="small-btn" onclick="showProfile()">Profil</button>
      </div>

      <hr style="border:none;height:8px"/>

      <h4>Kontakte</h4>
      <div class="contacts" id="contacts"></div>
      <input id="addContactInput" type="text" placeholder="Name hinzuf√ºgen">
      <button onclick="addContactByName()">Kontakt anlegen</button>

      <hr style="border:none;height:8px"/>

      <h4>Gruppen</h4>
      <div class="groups" id="groups"></div>
      <input id="newGroupName" type="text" placeholder="Gruppenname">
      <button onclick="createGroup()">Gruppe erstellen</button>

      <div class="footer-small">Demo: Firestore & Storage werden verwendet. Sicherheitsregeln pr√ºfen.</div>
    </div>
  </div>

  <div class="main" id="main">
    <div class="chat-header">
      <h3 id="chatTitle">Bitte anmelden</h3>
      <div id="callButtons" style="display:none;gap:8px">
        <button id="audioCallBtn" class="small-btn" title="Audioanruf">üìû</button>
        <button id="videoCallBtn" class="small-btn" title="Videoanruf">üé•</button>
        <button id="groupVideoBtn" class="small-btn" title="Gruppen-Video (nur Video)">üë•üé•</button>
        <button id="endCallBtn" class="small-btn" title="Auflegen" style="display:none">‚ùå</button>
      </div>
    </div>

    <div id="chatBox" class="chat-box"></div>
    <div id="typingIndicator" class="typing-indicator">Niemand schreibt gerade...</div>

    <div class="input-row">
      <input id="messageInput" type="text" placeholder="Schreib eine Nachricht...">
      <input id="imageInput" type="file" accept="image/*">
      <button onclick="sendMessage()">Senden</button>
      <button id="sendImageBtn" onclick="sendImage()">Bild senden</button>
    </div>
    <img id="previewImg" class="preview-img" style="display:none">

    <div id="videoContainer" style="margin-top:12px">
      <div id="videoGrid" class="video-grid"></div>
    </div>
  </div>
</div>

<!-- Incoming Popup -->
<div id="incomingPopup" class="incoming-popup" style="display:none">
  <h3 id="popupTitle">Eingehender Anruf</h3>
  <p id="popupCaller" class="muted"></p>
  <div style="display:flex;gap:8px">
    <button id="acceptCallBtn">Annehmen</button>
    <button id="declineCallBtn">Ablehnen</button>
  </div>
</div>

<script type="module">
/* === Firebase + WebRTC Full Implementation (Frontend-only) ===
   - Firestore collections used:
     - users (docs per uid)
     - messages (chat messages)
     - groups (group docs with members array)
     - groupCalls (docs per pair: from/to/group with offer/answer; subcollections: offerCandidates / answerCandidates)
   - NOTE: Replace firebaseConfig with your project's config for production.
*/

import { initializeApp } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-app.js";
import { getAuth, onAuthStateChanged, createUserWithEmailAndPassword, signInWithEmailAndPassword, signOut } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-auth.js";
import { getFirestore, doc, setDoc, collection, addDoc, query, where, getDocs, onSnapshot, orderBy, updateDoc, getDoc } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-firestore.js";
import { getStorage, ref, uploadBytes, getDownloadURL } from "https://www.gstatic.com/firebasejs/12.4.0/firebase-storage.js";

const firebaseConfig = {
  apiKey: "AIzaSyCFgiS9au7GOzhJ7_ayBcBM3bZrEm5GJOA",
  authDomain: "webchat-a47cc.firebaseapp.com",
  databaseURL: "https://webchat-a47cc-default-rtdb.europe-west1.firebasedatabase.app",
  projectId: "webchat-a47cc",
  storageBucket: "webchat-a47cc.appspot.com",
  messagingSenderId: "318380716143",
  appId: "1:318380716143:web:da7474bfa392dfeaccdd9a",
  measurementId: "G-GBFBS5F8GB"
};

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);
const storage = getStorage(app);

/* UI refs */
const authArea = document.getElementById('authArea');
const userArea = document.getElementById('userArea');
const userInfo = document.getElementById('userInfo');
const contactsDiv = document.getElementById('contacts');
const groupsDiv = document.getElementById('groups');
const chatBox = document.getElementById('chatBox');
const chatTitle = document.getElementById('chatTitle');
const callButtons = document.getElementById('callButtons');
const audioCallBtn = document.getElementById('audioCallBtn');
const videoCallBtn = document.getElementById('videoCallBtn');
const groupVideoBtn = document.getElementById('groupVideoBtn');
const endCallBtn = document.getElementById('endCallBtn');
const messageInput = document.getElementById('messageInput');
const imageInput = document.getElementById('imageInput');
const sendImageBtn = document.getElementById('sendImageBtn');
const previewImg = document.getElementById('previewImg');
const typingIndicator = document.getElementById('typingIndicator');
const videoGrid = document.getElementById('videoGrid');
const incomingPopup = document.getElementById('incomingPopup');
const popupCaller = document.getElementById('popupCaller');
const acceptCallBtn = document.getElementById('acceptCallBtn');
const declineCallBtn = document.getElementById('declineCallBtn');

let me = null;
let selectedPeer = null; // {type:'user'|'group', id:, name:}
let messagesUnsub = null;
let selectedFile = null;
let localStream = null;
let peerConnections = {}; // peerId -> RTCPeerConnection
let myOfferDocs = {};     // peerId -> docRef for offers we created (caller)
let activeGroupCallId = null; // current group id calling or in

const ICE_SERVERS = [{ urls: 'stun:stun.l.google.com:19302' }];
const GROUP_CALLS_COL = 'groupCalls'; // collection for pairwise offer docs for group calls

/* ---------- Auth ---------- */
window.signup = async () => {
  const email = document.getElementById('email').value;
  const pw = document.getElementById('password').value;
  if (!email || !pw) { alert('E-Mail + Passwort angeben'); return; }
  try { await createUserWithEmailAndPassword(auth, email, pw); }
  catch (e) { alert(e.message || e); }
};
window.login = async () => {
  const email = document.getElementById('email').value;
  const pw = document.getElementById('password').value;
  if (!email || !pw) { alert('E-Mail + Passwort angeben'); return; }
  try { await signInWithEmailAndPassword(auth, email, pw); }
  catch (e) { alert(e.message || e); }
};
window.logout = async () => {
  try { await signOut(auth); } catch (e) {}
  selectedPeer = null; chatBox.innerHTML = ''; videoGrid.innerHTML = ''; userArea.style.display = 'none'; authArea.style.display = 'block';
  // cleanup any local stream & pcs
  stopLocalStreams();
  for (const k in peerConnections) { try { peerConnections[k].close(); } catch (e) {} }
  peerConnections = {}; myOfferDocs = {}; activeGroupCallId = null;
};

/* ---------- Auth state listener ---------- */
onAuthStateChanged(auth, async (user) => {
  if (user) {
    me = { uid: user.uid, email: user.email, name: (user.email || '').split('@')[0] || 'User' };
    // write user doc
    try { await setDoc(doc(db, 'users', me.uid), me, { merge: true }); } catch (e) { console.error(e); }
    authArea.style.display = 'none'; userArea.style.display = 'block';
    userInfo.textContent = `Angemeldet als ${me.name}`;
    loadContacts(); loadGroups();
    chatTitle.textContent = 'W√§hle einen Chat';
    setupIncomingWatcher(); // listens for group call offers aimed at me
  } else {
    me = null;
    authArea.style.display = 'block'; userArea.style.display = 'none';
    chatTitle.textContent = 'Bitte anmelden';
    chatBox.innerHTML = ''; videoGrid.innerHTML = '';
  }
});

/* ---------- Load contacts & groups ---------- */
async function loadContacts() {
  contactsDiv.innerHTML = '';
  const uCol = collection(db, 'users');
  const snap = await getDocs(uCol);
  snap.forEach(d => {
    const u = d.data();
    if (u.uid === me.uid) return;
    const div = document.createElement('div'); div.className = 'contact-item';
    const left = document.createElement('span'); left.textContent = u.name || u.email || 'User';
    const right = document.createElement('span'); right.className = 'muted';
    div.appendChild(left); div.appendChild(right);
    div.onclick = () => { selectChat({ type: 'user', id: u.uid, name: u.name || u.email }); };
    contactsDiv.appendChild(div);
  });
}

async function loadGroups() {
  groupsDiv.innerHTML = '';
  const q = query(collection(db, 'groups'), where('members', 'array-contains', me.uid));
  const snap = await getDocs(q);
  snap.forEach(d => {
    const g = d.data();
    const div = document.createElement('div'); div.className = 'group-item';
    const left = document.createElement('span'); left.textContent = g.name || 'Gruppe';
    const right = document.createElement('span'); right.className = 'muted'; right.textContent = (g.members||[]).length + ' Mitglieder';
    div.appendChild(left); div.appendChild(right);
    div.onclick = () => { selectChat({ type: 'group', id: d.id, name: g.name }); };
    groupsDiv.appendChild(div);
  });
}

/* ---------- Chat logic ---------- */
async function selectChat(peer) {
  selectedPeer = peer;
  chatTitle.textContent = peer.name || 'Chat';
  chatBox.innerHTML = '';
  callButtons.style.display = (peer.type === 'user') ? 'flex' : 'none';
  if (messagesUnsub) messagesUnsub();
  // query messages: for simplicity we store messages with {from,to,...}
  let messagesQuery;
  if (peer.type === 'user') {
    messagesQuery = query(collection(db, 'messages'), orderBy('timestamp'));
  } else {
    messagesQuery = query(collection(db, 'messages'), where('to', '==', peer.id), orderBy('timestamp'));
  }
  messagesUnsub = onSnapshot(messagesQuery, snap => {
    chatBox.innerHTML = '';
    const typingUsers = new Set();
    snap.forEach(docu => {
      const m = docu.data();
      if (peer.type === 'user') {
        if ((m.from === me.uid && m.to === peer.id) || (m.from === peer.id && m.to === me.uid)) {
          renderMessage(m);
        }
      } else {
        if (m.to === peer.id) renderMessage(m);
      }
      if (m.typing && m.from !== me.uid) typingUsers.add(m.fromName || 'User');
    });
    typingIndicator.textContent = typingUsers.size ? `${Array.from(typingUsers).join(', ')} schreibt...` : 'Niemand schreibt gerade...';
    chatBox.scrollTop = chatBox.scrollHeight;
  });
}

function renderMessage(m) {
  if (!m) return;
  if (m.type === 'image') {
    const img = document.createElement('img'); img.src = m.url; img.className = 'preview-img message ' + (m.from === me.uid ? 'sent' : 'received');
    chatBox.appendChild(img);
  } else {
    const d = document.createElement('div'); d.className = 'message ' + (m.from === me.uid ? 'sent' : 'received'); d.textContent = (m.fromName ? `${m.fromName}: ` : '') + (m.text || '');
    chatBox.appendChild(d);
  }
}

/* send text */
window.sendMessage = async () => {
  if (!selectedPeer) { alert('W√§hle erst einen Chat'); return; }
  const text = messageInput.value.trim();
  if (!text) return;
  await addDoc(collection(db, 'messages'), { from: me.uid, fromName: me.name, to: selectedPeer.id, type: 'text', text, timestamp: Date.now() });
  messageInput.value = '';
};

/* image handling */
imageInput.addEventListener('change', e => {
  selectedFile = e.target.files[0];
  if (selectedFile) { previewImg.src = URL.createObjectURL(selectedFile); previewImg.style.display = 'block'; } else previewImg.style.display = 'none';
});
async function sendImage() {
  if (!selectedPeer) { alert('W√§hle erst einen Chat'); return; }
  if (!selectedFile) { alert('Keine Datei ausgew√§hlt'); return; }
  const clean = selectedFile.name.replace(/[^\w.-]/g, '_');
  const path = `chatImages/${me.uid}_${Date.now()}_${clean}`;
  const storageRef = ref(storage, path);
  const snap = await uploadBytes(storageRef, selectedFile);
  const url = await getDownloadURL(snap.ref);
  await addDoc(collection(db, 'messages'), { from: me.uid, fromName: me.name, to: selectedPeer.id, type: 'image', url, timestamp: Date.now() });
  selectedFile = null; imageInput.value = ''; previewImg.style.display = 'none';
}

/* typing indicator: write a lightweight typing message (demo) */
let typingTimer = null;
messageInput.addEventListener('input', async () => {
  if (!selectedPeer) return;
  // write a small typing doc by adding a message with typing flag (demo, not ideal for prod)
  await addDoc(collection(db, 'messages'), { from: me.uid, fromName: me.name, to: selectedPeer.id, typing: true, timestamp: Date.now() });
  clearTimeout(typingTimer);
  typingTimer = setTimeout(async () => {
    // send a typing=false marker (here we won't remove, it's demo)
  }, 1000);
});

/* ---------- Utilities ---------- */
function showNotification(title, body) {
  if (!("Notification" in window)) return;
  if (Notification.permission === "granted") new Notification(title, { body });
  else if (Notification.permission !== "denied") Notification.requestPermission().then(p => { if (p === "granted") new Notification(title, { body }); });
}

/* ---------- Group call signalling via Firestore (pairwise docs) ----------
   Approach:
   - Caller iterates group members (except self), creates an offer PC for each -> creates offer SDP
   - For each callee: addDoc(collection('groupCalls'), { from: me.uid, to: peerId, group: groupId, offer, active: true })
   - Caller listens to that doc for answer field; also creates subcollection 'offerCandidates' where caller pushes ICE
   - Callee listens for docs where to==me.uid and group==groupId and active==true, shows incoming popup; if accepts:
       - create PC, setRemoteDescription(offer), add tracks, createAnswer(), updateDoc(docRef, { answer })
       - write ICE candidates to subcollection 'answerCandidates'
   - Both sides listen for candidate subcollections and addIceCandidate accordingly.
   - To end: updateDoc(docRef, { active: false })
-------------------------------------------------------------------------*/

const groupCallsCol = collection(db, GROUP_CALLS_COL);

/* create RTCPeerConnection helper */
function createPC(role, peerId, docRef=null) {
  const pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });

  pc.onicecandidate = e => {
    if (!e.candidate) return;
    const cand = e.candidate.toJSON();
    if (!docRef) return;
    // caller writes to offerCandidates, callee to answerCandidates
    const colName = (role === 'caller') ? 'offerCandidates' : 'answerCandidates';
    addDoc(collection(docRef, colName), cand).catch(console.error);
  };

  pc.ontrack = e => {
    // attach to video element if exists; else create
    const id = 'video_' + peerId;
    let v = document.getElementById(id);
    if (!v) {
      v = document.createElement('video'); v.id = id; v.autoplay = true; v.playsInline = true; v.style.borderRadius = '8px';
      videoGrid.appendChild(v);
    }
    try { v.srcObject = e.streams[0]; } catch (err) { console.error(err); }
  };

  return pc;
}

/* Caller: start group video call */
async function startGroupVideoCall() {
  if (!selectedPeer || selectedPeer.type !== 'group') { alert('W√§hle eine Gruppe'); return; }
  // load group doc to get members
  const groupDocRef = doc(db, 'groups', selectedPeer.id);
  const groupSnap = await getDoc(groupDocRef);
  if (!groupSnap.exists()) { alert('Gruppendaten nicht gefunden'); return; }
  const groupData = groupSnap.data();
  const members = groupData.members || [];
  const others = members.filter(uid => uid !== me.uid);
  if (!others.length) { alert('Keine anderen Mitglieder'); return; }

  // get local stream
  try {
    localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
  } catch (e) {
    alert('Kamera/Mikrofon nicht verf√ºgbar'); console.error(e); return;
  }

  // show local video
  const localV = document.createElement('video'); localV.id = 'video_local'; localV.autoplay = true; localV.muted = true; localV.playsInline = true;
  localV.srcObject = localStream; videoGrid.appendChild(localV);

  // For each member create PC, createOffer and write doc
  for (const peerId of others) {
    const pc = createPC('caller', peerId);
    peerConnections[peerId] = pc;

    // add local tracks
    localStream.getTracks().forEach(track => pc.addTrack(track, localStream));

    // make offer
    const offerDesc = await pc.createOffer();
    await pc.setLocalDescription(offerDesc);

    // create call doc
    const callDoc = await addDoc(groupCallsCol, {
      from: me.uid,
      to: peerId,
      group: selectedPeer.id,
      offer: offerDesc.toJSON ? offerDesc.toJSON() : offerDesc,
      active: true,
      createdAt: Date.now()
    });

    myOfferDocs[peerId] = callDoc;

    // listen for answer on this doc
    onSnapshot(callDoc, async snap => {
      const data = snap.data();
      if (!data) return;
      if (data.answer && pc && !pc.currentRemoteDescription) {
        const ansDesc = new RTCSessionDescription(data.answer);
        await pc.setRemoteDescription(ansDesc).catch(console.error);
      }
      if (data.active === false) { // callee declined/ended
        try { pc.close(); } catch (e) {}
        delete peerConnections[peerId];
        // remove video element if exists
        const v = document.getElementById('video_' + peerId); if (v) v.remove();
      }
    });

    // listen for answerCandidates
    const answerCandidatesCol = collection(callDoc, 'answerCandidates');
    onSnapshot(answerCandidatesCol, snap => {
      snap.docChanges().forEach(change => {
        if (change.type === 'added') {
          const c = change.doc.data();
          pc.addIceCandidate(new RTCIceCandidate(c)).catch(console.error);
        }
      });
    });

    // also listen for offerCandidates is optional for caller (not needed if only caller pushes its own candidates)
    const offerCandidatesCol = collection(callDoc, 'offerCandidates');
    onSnapshot(offerCandidatesCol, snap => {
      snap.docChanges().forEach(change => {
        if (change.type === 'added') {
          const c = change.doc.data();
          // mostly duplicates for caller; ignore or use if necessary
        }
      });
    });
  }

  activeGroupCallId = selectedPeer.id;
  endCallBtn.style.display = 'inline-block';
}

/* Callee handling: watch for documents where to==me.uid and group==selectedPeer.id */
function setupIncomingWatcher() {
  // listen for all incoming group call offers targeted at me
  const q = query(groupCallsCol, where('to', '==', me ? me.uid : ''));
  onSnapshot(q, async snap => {
    snap.docChanges().forEach(async change => {
      if (change.type !== 'added') return;
      const data = change.doc.data();
      const docRef = change.doc.ref;
      if (!data || !data.active) return;
      // Only act on group offers (group present)
      if (!data.group) return;
      // If this offer is part of currently selected group, show popup ‚Äî else still notify
      const groupId = data.group;
      // Show incoming popup to user
      popupCaller.textContent = `Gruppe: ${groupId} ‚Äî von: ${data.from}`;
      incomingPopup.style.display = 'block';

      acceptCallBtn.onclick = async () => {
        incomingPopup.style.display = 'none';
        // create PC, setRemoteDescription(offer), add local tracks, create answer, update doc
        try {
          localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
        } catch (e) {
          alert('Kamera/Mikrofon nicht verf√ºgbar'); return;
        }
        // create pc for this caller (data.from)
        const callerId = data.from;
        const pc = createPC('answerer', callerId, docRef);
        peerConnections[callerId] = pc;

        // add local tracks
        localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
        // local video element
        let v = document.getElementById('video_local');
        if (!v) { v = document.createElement('video'); v.id = 'video_local'; v.autoplay = true; v.muted = true; v.playsInline = true; v.srcObject = localStream; videoGrid.appendChild(v); }

        // set remote (offer)
        const offer = data.offer;
        const offerDesc = new RTCSessionDescription(offer);
        await pc.setRemoteDescription(offerDesc);

        // create answer
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);

        // write answer to the same doc
        await updateDoc(docRef, { answer: answer.toJSON ? answer.toJSON() : answer, active: true });

        // listen for offerCandidates (from caller)
        const offerCandidatesCol = collection(docRef, 'offerCandidates');
        onSnapshot(offerCandidatesCol, snapc => {
          snapc.docChanges().forEach(ch => {
            if (ch.type === 'added') {
              const c = ch.doc.data();
              pc.addIceCandidate(new RTCIceCandidate(c)).catch(console.error);
            }
          });
        });

        // push our answer candidates to answerCandidates
        pc.onicecandidate = e => {
          if (!e.candidate) return;
          const cand = e.candidate.toJSON();
          addDoc(collection(docRef, 'answerCandidates'), cand).catch(console.error);
        };

        // listen for call deactivation
        onSnapshot(docRef, (s) => {
          const d = s.data();
          if (!d) return;
          if (d.active === false) {
            try { pc.close(); } catch (e) {}
            delete peerConnections[callerId];
            const rv = document.getElementById('video_' + callerId); if (rv) rv.remove();
          }
        });
      };

      declineCallBtn.onclick = async () => {
        incomingPopup.style.display = 'none';
        // mark this call doc as inactive (declined)
        await updateDoc(change.doc.ref, { active: false }).catch(console.error);
      };
    });
  });
}

/* Stop local streams helper */
function stopLocalStreams() {
  if (localStream) {
    localStream.getTracks().forEach(t => t.stop());
    localStream = null;
    const lv = document.getElementById('video_local'); if (lv) lv.remove();
  }
}

/* End all group calls (caller side) */
async function endAllGroupCalls() {
  // set active = false on all offer docs we created
  for (const peerId in myOfferDocs) {
    try { await updateDoc(myOfferDocs[peerId], { active: false }); } catch (e) {}
  }
  // cleanup
  for (const k in peerConnections) { try { peerConnections[k].close(); } catch (e) {} }
  peerConnections = {}; myOfferDocs = {}; activeGroupCallId = null;
  stopLocalStreams();
  endCallBtn.style.display = 'none';
  videoGrid.innerHTML = '';
}

/* UI hook for group video start */
groupVideoBtn.onclick = () => startGroupVideoCall();

/* UI hook for end call */
endCallBtn.onclick = () => endAllGroupCalls();

/* helper: create contact / group (demo) */
window.addContactByName = async () => {
  const n = document.getElementById('addContactInput').value.trim();
  if (!n) return alert('Name angeben');
  const fid = 'tmp_' + Date.now();
  await setDoc(doc(db, 'users', fid), { uid: fid, name: n, email: `${n}@example.local` });
  loadContacts();
};

window.createGroup = async () => {
  const name = document.getElementById('newGroupName').value.trim();
  if (!name) return alert('Gruppenname angeben');
  // initial member: me (for demo)
  await addDoc(collection(db, 'groups'), { name, members: [me.uid], created: Date.now() });
  loadGroups();
};

/* small helpers */
function showProfile(){ alert(`Profil: ${me ? me.name : '‚Äî'}`); }

/* load initial if logged in */
if (Notification && Notification.permission !== "granted") { Notification.requestPermission().catch(()=>{}); }

</script>
</body>
</html>














